#!/usr/local/bin/python -u
helpstr = '''
  _           _                        _   
 (_)_ __  ___| |_ __ _ _ __   ___  ___| |_ 
 | | '_ \/ __| __/ _` | '_ \ / _ \/ __| __|
 | | | | \__ \ || (_| | |_) | (_) \__ \ |_ 
 |_|_| |_|___/\__\__,_| .__/ \___/|___/\__|
                      |_|v1.2.1 5/16/2017
                 
post data to CWMSv3+ databases in realtime
'''

import argparse, re, sys, os, yaml, tslite, pytz, json, cx_Oracle, datetime
import dateutil.parser as dateparser

#Read Configuration File
myloc = sys.argv[0].replace("instapost", "")  #determine where executable lives
conf = json.loads(open(myloc + "instapost.json", "r").read())
#Add relevent entriys to environment variables
os.putenv("ORACLE_HOME", conf["ORACLE_HOME"])
sys.path.append(conf["PATH"])

###############################################################################

def log(message, level="MSG"):
  '''
  log code which returns parsable logs in the following format
  <ISO 8601 date> <Logging Level> <message>
  '''
  output = sys.stdout
  if args.verbose or (level != "STOR" and level != "MSG"):
    if level != "STOR":
      output = sys.stderr
    output.write("%s\t%s\t%s\n" %
                 (datetime.datetime.now().isoformat(), level, message))
  if level == "FATAL":
    sys.exit(-1)


###############################################################################
# Class that connects to the database


class dataService:

  def __init__(self):
    self.status = "OK"
    self.configuration = self.getDefaultConfiguration()
    self.dbconn = None
    self.cur = None

  def connect(self):
    try:
      dbname = self.configuration["dbname"]
      self.dbconn = cx_Oracle.Connection(
          user=self.configuration["dbuser"],
          password=self.configuration["dbpassword"],
          dsn=dbname)
      if not self.dbconn:
        self.status = "Could not connect to %s" % dbname
      else:
        self.cur = self.dbconn.cursor()
    except Exception, e:
      self.status = "Could not connect to %s: %s" % (dbname, str(e))

  def disconnect(self):
    if self.cur != None:
      self.cur.close()
    self.dbconn.close()

  def getDefaultUnits( self, tsid ):
    try:
      tsid = tsid.lower()
      tokens = tsid.split( "." )

      #check to see if full Parameter is in default units and return
      param = tokens[1]
      if param in self.configuration["defaultUnits"]:
        return self.configuration["defaultUnits"][param]

      #check to see if parameter is in default units and return
      param = tokens[1].split( "-" )[0]
      if param in self.configuration["defaultUnits"]:
        return self.configuration["defaultUnits"][param]
    except:
      pass
    return ""                            # Use database default


  def getDefaultConfiguration(self):
    conf = {
        "timeFormat": "%d-%b-%Y %H%M",
        "timeZone": "GMT",
        "dbuser": "",
        "dbpassword": "",
        "dbname": self.getDBname(),
        "office": "NWDP",
        "defaultUnits": {}
    }
    return conf

  def updateConfiguration(self, newConf):
    for key in newConf:
      self.configuration[key] = newConf[key]
      if self.configuration["dbname"] == "detect":
        self.configuration["dbname"] = self.getDBname()

  def getDBname(self):
    return os.uname()[1].upper()[0:3]  #determine which database to connect to

  def readTS(self, tsid, start_time, end_time, units):
    timefmt = self.configuration["timeFormat"]
    office = self.configuration["office"]
    try:
      ts_cur = self.cur.var(cx_Oracle.CURSOR)
      if units.lower() == "default":
        units = self.getDefaultUnits(tsid)
      self.cur.callproc('cwms_ts.retrieve_ts',
                        [ ts_cur, tsid, units,
                          start_time.astimezone( pytz.utc ),
                            end_time.astimezone( pytz.utc ) ])
      output = []
      for record in ts_cur.getvalue():
        output.append(list(record))
        #log (str(output[-1]))
        output[-1][0] = record[0].replace( tzinfo=pytz.utc )
    except Exception, e:
      self.status = "Could not retrieve %s: %s" % (tsid, str(e))
      log(self.status)
      return []
    return output

  def writeToCWMS(self, tsid, units, valueList):
    self.status = "OK"
    #cur = self.dbconn.cursor()
    timefmt = self.configuration["timeFormat"]
    office = self.configuration["office"]
    if units.lower() == "default":
      units = self.getDefaultUnits(tsid)
    times, values, qualities = [], [], []
    zero_time = datetime.datetime(1970, 1, 1, tzinfo=pytz.utc)
    for row in valueList:
      (stamp, val) = row[:2]
      times.append((stamp - zero_time).total_seconds() * 1000)
      values.append(val)
      qualities.append(0)
      log("%s\t%s\t%s\t%s" % (tsid, stamp.isoformat(), val, units),
          level="STOR")
    try:
      if values != []:
        self.cur.callproc('cwms_ts.store_ts', [
            tsid, units, times,
            self.cur.arrayvar(cx_Oracle.NATIVE_FLOAT, values), qualities,
            'REPLACE ALL'
        ])
      log("Wrote %d values." % len(values))
    except Exception, e:
      self.status = "Could not store %s: %s" % (tsid, str(e))
      log(self.status, level="ERROR")

  def writeDiff(self, tsid, units, ts):
    ''' this writes the difference between values in the database and provided timeseries '''
    if ts:
      if len(ts.data) > 0:
        starttime = ts.data[0][0]
        endtime = ts.data[-1][0]
      else:
        return
      dbts = tslite.timeseries(self.readTS(tsid, starttime, endtime, units))
      if dbts == None:
        dbts = tslite.timeseries()
        log(tsid + " does not exist")
      self.writeToCWMS(tsid, units, dbts.diff(ts).data)


###############################################################################


def process(raw, fmt):
  if fmt == "YAML":
    raw = yaml.safe_load(raw)
  else:
    raw = json.loads(raw)
  if raw == None:
    return
  for tsid in raw:
    log("Processing: " + tsid)
    ts = tslite.timeseries()
    units = raw[tsid].get("units", "default")
    mytz = pytz.timezone(raw[tsid].get("timezone", "GMT"))
    rawts = raw[tsid].get("timeseries", {})
    if rawts == None:
      log(tsid+" has no values.", level="WARN")
    else:
      for key in rawts:
        try:
          if isinstance( key, datetime.datetime ):
            tstamp = key
          else:
            tstamp = dateparser.parse(key, fuzzy=True)
          if tstamp.tzinfo == None:
            tstamp = mytz.localize(tstamp)
          ts.insert(tstamp, float(rawts[key]))
        except Exception, e:
          log(str(e), level="ERROR")
      ds.writeDiff(tsid, units, ts )


def post(infile, fmt="YAML"):
  try:
    raw = []
    for line in infile:
      if line.strip() == "---":
        if raw != []: process("".join(raw), fmt)
        raw = []
      else:
        raw.append(line)
    if raw != []:
      process("".join(raw), fmt)
  except Exception, e:
    log(str(e), level="FATAL")


###############################################################################

p = argparse.ArgumentParser(
    description=helpstr, formatter_class=argparse.RawDescriptionHelpFormatter)
p.add_argument('-v', '--verbose', action='store_true', help='Work verbosely')
p.add_argument('-t', '--tsv', action='store_true', help='input in TSV format')
p.add_argument('-p', '--pathname', help='database pathname to store TSV file')
p.add_argument('-y', '--yaml', action='store_true', help='input in YAML format')
p.add_argument('-j', '--json', action='store_true', help='input in JSON format')
p.add_argument('-f', '--file', help='specify input file (default is STDIN)')
args = p.parse_args()

infile = sys.stdin
if args.file:
  try:
    log("Using file from disk: " + args.file)
    infile = open(args.file, "r")
  except:
    log("File Not found: " + args.file, level="FATAL")

ds = dataService()
ds.updateConfiguration(conf)
ds.connect()
if ds.status == "OK":
  log("Connected to: " + ds.configuration["dbname"])
else:
  log(ds.status, level="FATAL")

if args.tsv:
  rdb_to_file(rdb, id, dest, sensors, mode)
if args.json:
  post(infile, fmt="JSON")
else:
  post(infile)
ds.disconnect()
# vim: tabstop=2 expandtab shiftwidth=2 softtabstop=2
